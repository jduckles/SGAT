##' Bin locations to form a 2D density raster
##'
##' Bins the samples for a sequence of locations to produce a raster.
##' Optionally, a vector of weights can be provided to differentially
##' weight samples by location.
##'
##' @title Location Density Raster
##' @param s an array of location samples generated by
##' \code{estelle.metropolis} or \code{stella.metropolis}.
##' @param grid raster object that defines the sampling grid
##' @param weights weights for each location
##' @param zero.is.na if \code{TRUE}, zero counts are returned as \code{NA}.
##' @return a raster representing a 2D histogram of locations
##' @export
location.rasterize <- function(s,grid,weights=1,zero.is.na=TRUE) {
  if(length(dim(s))==4) s <- chain.collapse(s)
  weights <- rep(weights,length=dim(s)[1])
  r <- if(is.null(grid)) raster() else raster(grid)

  ## Project coords
  if(!isLonLat(r)) {
    from <- CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs +towgs84=0,0,0")
    to <- CRS(projection(r))
    p <- cbind(as.vector((s[,1,]+180)%%360-180),as.vector(s[,2,]))
    p <- coordinates(spTransform(SpatialPoints(p, proj4string = from),to))
    s[,1,] <- p[,1]
    s[,2,] <- p[,2]
  }

  ## Do the binning
  bb <- bbox(r)
  nx <- ncol(r)
  ny <- nrow(r)
  xbin <- seq(bb[1,1],bb[1,2],length=nx+1)
  ybin <- seq(bb[2,1],bb[2,2],length=ny+1)

  A <- 0
  W <- prod(dim(s)[-(1:2)])
  for(k in seq(length=dim(s)[1])) {
    A <- A+weights[k]/W*table(
      factor((ny+1)-.bincode(s[k,2,],ybin,TRUE,TRUE),levels=1:ny),
      factor(.bincode(s[k,1,],xbin,TRUE,TRUE),levels=1:nx))
  }
  if(zero.is.na) A[A==0] <- NA
  values(r) <- A
  r
}



##' Generate density estimates for time slices of a trip
##'
##' These functions allow a trip to be divided into time slices, and
##' location density estimates generated for each time slice.
##'
##' The \code{slices} function defines the slices into which the
##' trip is divided, and whether the primary or intermediate locations
##' are to be binned. If \code{breaks} is NULL, each location forms a
##' separate time slice, otherwise \code{breaks} divides the trip into
##' time slices in the same style as \code{\link{cut.POSIXt}}.  A
##' default set of samples and a raster defining the spatial bins may
##' also be specified.
##'
##' The \code{slice} function generates the binned locations for a
##' single time slice as a raster, \code{slice.interval} returns the
##' corresponding time interval, and \code{slice.indices} returns the
##' indices that will yield non null raster.
##'
##' @title Location Density Estimates
##' @param type construct density rasters for primary (\code{"x"}) or
##' intermediate (\code{"z"}) locations
##' @param slices an object generated by \code{slices} defining the
##' @param k the index of the time slice to bin.
##' @param breaks NULL, or a specification suitable for
##' \code{cut.POSIXt} to define the time slices to bin.
##' @param mcmc object generated by generated by
##' \code{estelle.metropolis} or \code{stella.metropolis}.
##' @param grid raster object that defines the sampling grid
##' @param include.lowest parameter to \code{cut.POISXt}.
##' @param right parameter to \code{cut.POSIXt}
##' @param chains NULL or the subset of chains to bin.
##' @param zero.is.na if \code{TRUE}, zero counts are returned as \code{NA}.
##' @return \code{slice} returns the locations for time slice of the
##' track binned into a raster, \code{slices} returns a slices
##' object that defines the time slices into which to bin,
##' \code{slice.interval} returns the time interval spanned by a
##' slice, and \code{slice.indices} returns the valid set of indices
##' that will yield a raster.
##' @export
slice <- function(slices,k,mcmc=slices$mcmc,grid=slices$grid,
                  chains=NULL,zero.is.na=TRUE) {
  ## Split times
  time <- mcmc$model$time
  if(!is.null(slices$breaks))
    k <- which(k==unclass(cut(if(slices$type=="z") time[-length(time)] else time,
                 slices$breaks,
                 include.lowest=slices$include.lowest,
                 right=slices$right)))
  if(length(k)>0) {
    ## Select x or z
    if(slices$type=="z") {
      w <- diff(as.numeric(time)/(60*60))
      s <- mcmc$z
    } else {
      w <- rep(1,length(time))
      s <- mcmc$x
    }

    ## Subset
    w <- w[k]
    if(length(dim(s))==4) {
      s <- if(is.null(chains)) s[k,,,,drop=FALSE] else s[k,,,chains,drop=FALSE]
    } else {
      s <- s[k,,,drop=FALSE]
    }
    ## Convert
    location.rasterize(s,grid,w,zero.is.na)
  }
}


##' @rdname slice
##' @export
slices <- function(type=c("x","z"),breaks=NULL,
                   mcmc=NULL,grid=raster(),
                   include.lowest=TRUE,right=FALSE) {
  r <- list(type=match.arg(type),
            breaks=breaks,
            mcmc=mcmc,
            grid=grid,
            include.lowest=include.lowest,
            right=right)
  class(r) <- "slices"
  r
}


##' @rdname slice
##' @export
slice.interval <- function(slices,k,mcmc=slices$mcmc) {
  time <- mcmc$model$time
  if(!is.null(slices$breaks))
    k <- which(k==unclass(cut(if(slices$type=="z") time[-length(time)] else time,
                 slices$breaks,
                 include.lowest=slices$include.lowest,
                 right=slices$right)))
  if(length(k)>0) range(time[if(slices$type=="z") c(k,k+1) else k])
}

##' @rdname slice
##' @export
slice.indices <- function(slices,mcmc=slices$mcmc) {
  time <- mcmc$model$time
  if(slices$type=="z") time <- time[-length(time)]
  if(!is.null(slices$breaks))
    unique(unclass(cut(time,
                       slices$breaks,
                       include.lowest=slices$include.lowest,
                       right=slices$right)))
  else
    1:length(time)
}


##' Extract longitude and latitude of raster cells.
##'
##' Extract the longitude and latitude of the center of the requested
##' cells of a Raster* object, similar to \code{xyFromCell}.
##' @title Raster cell longitude and latitudes
##' @param raster a raster object
##' @param cells the cell numbers
##' @param spatial return locations as SpatialPoints object instead of a matrix.
##' @return the long,lat locations for the requested cells.
##' @export
longlatFromCell <- function(raster,cells,spatial=FALSE) {
  if(isLonLat(raster)) {
    xyFromCell(raster,cells,spatial=spatial)
  } else {
    p <- spTransform(xyFromCell(raster,cells,spatial=TRUE),
                     CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs +towgs84=0,0,0"))
    if(spatial) p else coordinates(p)
  }
}

##' Spatial maps of twilight residuals
##'
##' This function calculates the twilight residuals corresponding to
##' an observed twilight across a grid of locations.
##'
##' @title Twilight Residuals
##' @param twilight an observed time of twilight
##' @param rise \code{TRUE} if twilight is a sunrise
##' @param grid raster object that define the sampling grid.
##' @param zenith the solar zenith angle that defines twilight.
##' @return a raster of twilight residuals (in minutes).
##' @export
solar.residuals <- function(twilight,rise,grid,zenith=96) {
  p <- longlatFromCell(grid,1:ncells(grid))
  legal <- !(is.na(p[,1]) | is.na(p[,2]))
  sgn <- if(rise) 1 else -1
  s <- solar(twilight)
  r <- raster(grid)
  r[legal] <- 4*sgn*(s$solarTime-twilight.solartime(s,p[legal,1],p[legal,2],rise,zenith))
  r
}
